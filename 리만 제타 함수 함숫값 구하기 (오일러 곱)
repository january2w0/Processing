int N = 100;  // N의 범위 정하기
int n = 1;  // n이 0이면 소수의 개수를 1부터 셈
int Nf = 0;  // Number of factors
int Np = 0;  // Number of primes
int Difference = 0;
ArrayList Prime = new ArrayList();
int s = 2;  // 제곱할 값
double y = 1;
double pi = Math.pow(PI,s);
double Total = 0; 
double A = 0; // 소수들의 평균차잇값

void setup() {
  size(1500,500);
  while (n < N) {  
    n++;
    int Previous = Np;
    Nf = 0;
    for (int k=1; k*k<=n; k++) {
      if (n%k == 0) {
          Nf++;
      }
    }
    if (Nf == 1) {
      Np++;
      if (Np > Previous) {
        Prime.add(Previous, n);
        if (Np > 1) {
          Difference = (int)Prime.get(Previous) - (int)Prime.get(Previous-1);
          Total += Difference;
          A = Total/Previous;
        }
      }
    }
    float Np1 = Np;
    print("N: "+n, " ");
    print("Np: "+Np, " ");
    float P = (Np1/n) * 100;  // n까지의 소수 밀도를 백분율로 나타냄.
    print("P: "+P+"%", " ");
    
    if (Previous - Np < 0) {
      y *= (Math.pow((int)Prime.get(Np-1),s)/(Math.pow((int)Prime.get(Np-1),s) - 1));
    }
    print("ζ("+s+"): "+y, "=", "π^("+s+")"+"/"+1/(y/pi), " ");  // 리만 제타 함수의 함숫값 출력하기
    
    println("Average: "+A); // 소수들의 평균차잇값값 출력하기
    
    println(Prime); // N까지의 모든 소수 출력하기
    println(" ");
    
    point(n/5*2,500-P*5);  // x축 n, y축 밀도 그래프 그리기
  }
}
