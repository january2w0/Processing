int N = 1000;  // N의 범위 정하기
int Nf = 0;  // Number of factors
int Np = 0;  // Number of primes
ArrayList Prime = new ArrayList();
int s = 2;  // 제곱할 값
double y = 1;
double pi = Math.pow(PI,s);
double Total = 0; 
double A = 0; // 소수들의 평균차잇값
float sx = 1500, sy = 500;
float px = 0, py = 0, previous_px = 0;
float previous_py1 = 500, previous_py2 = 500, previous_py3 = 500;

void setup() {
  size(1500, 500);
  for (int n=2; n<=N; n++) {  // n이 1부터 시작하면 소수의 개수를 1부터 셈
    println(" ");
    int Previous = Np;
    Nf = 0;
    for (int k=1; k*k<=n; k++) {
      if (n%k == 0) {
          Nf++;
      }
    }
    if (Nf == 1) {
      Np++;
      if (Np > Previous) {
        Prime.add(Previous, n);
        if (Np > 1) {
          int Difference = (int)Prime.get(Previous) - (int)Prime.get(Previous-1);
          Total += Difference;
          A = Total/Previous;
        }
      }
    }
    float Np1 = Np;
    print("N: "+n, " ");
    print("Np: "+Np, " ");
    float P = (Np1/n) * 100;  // n까지의 소수 밀도를 백분율로 나타냄.
    print("P: "+P+"%", " ");
    
    if (Previous - Np < 0) {
      y *= (Math.pow((int)Prime.get(Np-1),s)/(Math.pow((int)Prime.get(Np-1),s) - 1));
    }
    print("ζ("+s+"): "+y, "=", "π^("+s+")"+"/"+1/(y/pi), " ");  // 리만 제타 함수의 함숫값 출력하기
    
    println("Average: "+A); // 소수들의 평균차잇값값 출력하기
    
    //println(Prime); // N까지의 모든 소수 출력하기
    
    if (N/sx > 0) {
      px = n/(N/sx);
      py = 500 - 2*Np/(N/sx);
    } else {
      px = n*(sx/N);
      py = 500 - Np*(sx/N);
    }  
    //point(px, py);  // x축 n, y축 소수 개수 그래프 그리기 
    //line(previous_px, previous_py1, px, py);
    //point(px, 500-P*6);  // x축 n, y축 밀도 그래프 그리기
    //line(previous_px, previous_py2, px, 500-P*6);
    float A1 = (float)A;
    //point(px, 500-A1*30);  // x축 n, y축 평균차잇값 그래프 그리기
    line(previous_px, previous_py3, px, 500-A1*30);
    previous_px = px;
    previous_py1 = py;
    previous_py2 = 500-P*6;
    previous_py3 = 500-A1*30;
  }
  //println(Prime); // N까지의 모든 소수 출력하기
}
