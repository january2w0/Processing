int N = 10000;  // N의 범위 정하기
int Nf = 0;  // Number of factors
int Np = 0;  // Number of primes
ArrayList Prime = new ArrayList();
int s = 2;  // 제곱할 값
double y = 1;
double pi = Math.pow(PI,s);
double Total = 0; 
double A = 0; // 소수들의 평균차잇값
float sx = 1500, sy = 500;
float px = 0, py = 0, py2 = 0, py3 = 0, previous_px = 0;
float previous_py1, previous_py2, previous_py3,
previous_py4, previous_py5, previous_py6 = sy;
int m, n = 5;
  PImage img; 

void setup() {
  size(1500, 500);
  background(200);
  textSize(12);
  for (int n=2; n<=N; n++) {  // n이 1부터 시작하면 소수의 개수를 1부터 셈
    println(" ");
    int Previous = Np;
    Nf = 0;
    for (int k=1; k*k<=n; k++) {
      if (n%k == 0) {
          Nf++;
      }
    }
    if (Nf == 1) {
      Np++;
      if (Np > Previous) {
        Prime.add(Previous, n);
        if (Np > 1) {
          int Difference = (int)Prime.get(Previous) - (int)Prime.get(Previous-1);
          Total += Difference;
          A = Total/Previous;
        }
      }
    }
    float A1 = (float)A;
    float Np1 = Np;
    print("N: "+n, " ");
    print("Np: "+Np, " ");
    float P = (Np1/n) * 100;  // n까지의 소수 밀도를 백분율로 나타냄.
    print("P: "+P+"%", " ");
    /*double eNp = n/(100*pow(P,-1));  // n/(log(n)-(log(n)-100*pow(P,-1)))의 식과 같다
    print("eNp: "+eNp, " "); // 예상 소수개수 출력하기*/
    
    if (Previous - Np < 0) {
      y *= (pow((int)Prime.get(Np-1),s)/(pow((int)Prime.get(Np-1),s) - 1));
    }
    print("ζ("+s+"): "+y, "=", "π^("+s+")"+"/"+1/(y/pi), " ");  // 리만 제타 함수의 함숫값 출력하기
    
    println("Average: "+A); // 소수들의 평균차잇값 출력하기
    
    //println(Prime); // N까지의 모든 소수 출력하기
    
    if (N/sx > 1) {
      px = n/(N/sx);
      py = sy - 10*Np/(N/sy);
      py2 = sy - 10*(n/A1)/(N/sy);
      py3 = sy - 10*(n/(100*pow(P,-1)))/(N/sy);
    } else {
      px = n*(sx/N);
      py = sy - 10*Np*(sy/N);
      py2 = sy - 10*(n/A1)*(sy/N);
      py3 = sy - 10*(n/(100*pow(P,-1)))*(sy/N);
    }  
    //point(px, py);  // x축 n, y축 소수 개수 그래프 그리기 
    //line(previous_px, previous_py1, px, py);
    //point(px, 500-P*6);  // x축 n, y축 밀도 그래프 그리기
    //line(previous_px, previous_py2, px, 500-P*6);
    //point(px, 500-A1*30);  // x축 n, y축 평균차잇값 그래프 그리기
    //line(previous_px, previous_py3, px, 500-A1*30);
    //point(px, py2);  // 평균차잇값을 이용한 소수개수 그래프 그리기
    //line(previous_px, previous_py4, px, py2);
    //point(px, 500-300*(log(n)-100*pow(P,-1)));  // 소수개수의 근사치를 구하는 함수의 보정값 그래프 그리기
    //line(previous_px, previous_py5, px, 400-300*(log(n)-100*pow(P,-1)));
    //point(px, py3);  // 소수개수의 근사치를 구하는 함수의 보정된 그래프 그리기
    line(previous_px, previous_py6, px, py3);
    previous_px = px;
    //previous_py1 = py;
    //previous_py2 = 500-P*6;
    //previous_py3 = 500-A1*30;
    //previous_py4 = py2;
    //previous_py5 = 400-300*(log(n)-100*pow(P,-1));
    previous_py6 = py3; 
  }
  saveFrame("images/result-###.png");
  //println(Prime); // N까지의 모든 소수 출력하기
  /*float stdX = 10, stdY = 5; // 점 표시하기
  if (N/sx > 1) {
    stroke(255, 50, 50);
    line(stdX/(N/sx), 0, stdX/(N/sx), sy);
    line(0, sy - 10*stdY/(N/sy), sx, sy - 10*stdY/(N/sy));
  } else {
    stroke(255, 50, 50);
    line(stdX/(N/sx), 0, stdX/(N/sx), sy);
    line(0, sy - 10*stdY*(sy/N), sx, sy - 10*stdY*(sy/N));
  }*/
}

void draw() {
  m = 5;
  n = 5; 
  img = loadImage("images/result-000.png");
  image(img, 0 , 0, sx, sy);
  stroke(255, 50, 50);
  line(mouseX, 0, mouseX, sy);
  line(0, mouseY, sx, mouseY);
  if (mouseX > 1380) {
    m = -110;
  } 
  if (mouseY < 20) {
    n = -20;
  } 
  if (N/sx > 1) {
    float stdX = mouseX*(N/sx), stdY = ((sy-mouseY)/10)*(N/sy);
    fill(255, 50, 50);
    text("("+stdX+", "+stdY+")", mouseX+m, mouseY-n);  // 좌표표시 같이 움직이기
    //text("("+stdX+", "+stdY+")", 5, 17); // 좌표표시 고정하기
  } else {
    float stdX = mouseX*(N/sx), stdY = ((sy-mouseY)/10)/(sy/N);
    fill(255, 50, 50);
    text("("+stdX+", "+stdY+")", mouseX+m, mouseY-n);
    //text("("+stdX+", "+stdY+")", 5, 17);
  }
}
